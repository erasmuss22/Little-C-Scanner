<HTML>
<HEAD>
  <TITLE>CS 536, Program 2</title>
</HEAD>
<BODY>

<H1>CS 536, Program 2
<br>
The Scanner
</H1>
  <H2>
  <pre>
       Test Code and Errors.txt files Due: Thursday, February 23 (by midnight)
       Not accepted late

       Other Files Due: Sunday, February 26 (by midnight).
       Not accepted after midnight on Wed, February 29.
  </pre>
 </H2>

<BODY>

<hr>

<a name="contents">
<h2>Contents</h2>
</a>

<ul>
  <li> <a href="#news"> Clarifications and Corrections</a>
  <li> <a href="#introduction">Overview</a>
  <li> <a href="#jlex">JLex</a>
  <li> <a href="#LittleLanguage">The Little Language</a>
  <li> <a href="#scannerActions">What the Scanner Should Do</a>
  <li> <a href="#errors">Errors and Warnings</a>
  <li> <a href="#main">The Main Program</a>
  <li> <a href="#findErrors">Finding Errors in a Scanner</a>
  <li> <a href="#pairs">Working in Pairs</a>
  <li> <a href="#turningIn">What to Turn In</a>
</ul>

<hr>

<a name="news">
<h2>Clarifications and Corrections</h2>
</a>
<UL>
   <LI> none yet...
</UL>

<p>
<a name="introduction">
<h2>Overview</h2>
</a>

For this assignment you will use JLex to write a scanner
for a language called <code>Little</code>, a small subset of the C language.
Features of <code>Little</code> that are relevant to this assignment
are described below.
You will also write a main program (P2.java) to test your scanner, and
you will use your P2.java to find errors in a scanner that we will provide.
You will be graded on the correctness of your scanner,
how thoroughly your main program tests the scanner,
and whether you are able to use your main program to
find errors in the scanner that we provide.
<p>
Skeleton files on which you should build are in:
<tt>~cs536-1/public/html/PROG2</tt>
<P>
The files are:
<UL>
  <LI> <A HREF="../PROG2/Little.jlex"><tt>Little.jlex</tt></a>:
       An example JLex specification.  You will need to add to this file.
  <LI> <A HREF="../PROG2/sym.java"><tt>sym.java</tt></a>:
       Token definitions (this file will eventually be
       generated by the parser generator).  Do not change this file.
  <LI> <A HREF="../PROG2/Errors.java"><tt>Errors.java</tt></a>:
       The Errors class will be used to print error and warning messages.
       Do not change this file.
  <LI> <A HREF="../PROG2/P2.java"><tt>P2.java</tt></a>:
       Contains the main program that tests the scanner.
       You will need to add to this file.
  <LI> <A HREF="../PROG2/Makefile"><tt>Makefile</tt></a>: A Makefile that
       uses JLex to create a scanner, and also makes <tt>P2.class</tt>.
       You can change this file, but it should only be necessary if
       you write new files (e.g., auxiliary files for P2), and I don't
       think you need to do that.
</UL>

<a name="jlex">
<h2>JLex</h2>
</a>
<P>
Use the on-line
<a href="../NOTES/manual.html">
JLex reference manual</a>, and/or the on-line
<a href="../NOTES/2a.JLEX.html">
JLex notes</a> for information about writing a JLex specification.
<p>
If you work on a CS Dept Linux machine, you should have no problem
running JLex.
You will not be able to work on the CS Dept Windows machines.
Here are <a href="jarFiles.html">instructions</a> to follow if
you want to work on another machine.


<a name="LittleLanguage">
<h2>The <code>Little</code> Language</h2>
</a>

This section defines the lexical level of the <code>Little</code> language.
At this level, we have the following language issues:
<dl>
<dt> TOKENS
<dd>
The tokens of the <code>Little</code> language are defined as follows:
<ul>
  <li> Any of the following reserved words (remember that you will
       need to give the JLex patterns for reserved words <i>before</i>
       the pattern for identifiers):
      <pre>
   int void double if else while return scanf printf
      </pre>
  <li> Any identifier (a sequence of one or more letters and/or digits,
       and/or underscores, starting with a letter or underscore, excluding
       reserved words).
   <li> The two strings
   <ul>
   <tt>"%d"  "%f"</tt>
   </ul>
   which will be used for reading and writing integer and double values (as the
   first argument to <textit>scanf</textit> and <textit>printf</textit>).
   You will need to give the JLex patterns for these two tokens 
   (the <tt>INT_FORMAT</tt> and <tt>DBL_FORMAT</tt> token) <i>before</i>
   the pattern for string literals.
  <li> Any integer literal (a sequence of one or more digits).
  <li> Any double literal (a sequence of digits, followed by a dot,
       followed by a sequence of digits; one but not both sequences of digits
       can be empty).
  <li><a name="strLt">
       Any string literal (a sequence of zero or more <i>string</i> characters
       surrounded by double quotes. A <i>string</i> character is either
       <UL>
         <LI> an escaped character: a backslash followed by any one of the
              following five characters:
          <OL>
            <LI> <tt>n</tt>
            <LI> <tt>t</tt>
            <LI> a single quote
            <LI> a double quote
            <LI> another backslash
          </OL> 
             or
        <LI> a single character other than newline or double quote or
             backslash.
       </UL>
       <P>
       Examples of legal string literals:
       <pre>
   ""
   "&!#88"
   "use \n to denote a newline character"
   "include a quote like this \" and a backslash like this \\"
       </pre>
       Examples of things that are <em>not</em> legal string literals:
       <pre>
   "unterminated
   "also unterminated \"
   "backslash followed by space: \ is not allowed"
   "bad escaped character: \a AND not terminated
       </pre>
  <li> Any of the following one- or two-character symbols:
   <pre>
   {      }     (      )      ,      =      ;
   +      -     *      /      ++     --
   !      &&    ||     ==    !=      <      >      <=     >=
   &
   </pre>
</ul>
<P>
Token "names" (i.e., values to be returned by the scanner)
are defined in the file
<tt><a href="../PROG2/sym.java">sym.java</a></tt>.
For example, the name for the token to be returned when an integer
literal is recognized is <tt>INTLITERAL</tt>, the token to be
returned when the reserved word <tt>int</tt> is recognized is
<tt>INT</tt>, and the token to be returned when the format-string
<tt>"%d"</tt> is recognized is <tt>INT_FORMAT</tt>.
<P>
If you're not sure which token name matches which token, ask!
<P>
Note that code telling JLex to return the special EOF token on
end-of-file has already been included in the file <tt>Little.jlex</tt>
-- you don't have to include a specification for that token.

<P>
<dt> COMMENTS
<dd>
Comments are delimited by /* and */.
The scanner should recognize and ignore comments (but there is no
<tt>COMMENT</tt> token).
It should also recognize unterminated comments and give an error message
(see <a href=#errors>below</a> under "Errors and Warnings").
Don't forget to set the character counter to the correct value
following a comment (see below under "What the Scanner Should Do" for
a discussion of the character counter).

<P>
<dt> WHITESPACE
<dd>
Spaces, tabs, and newline characters are whitespace.
Whitespace separates tokens and changes the character counter,
but should otherwise be ignored (except inside a string literal).

<P>
<dt> ILLEGAL CHARACTERS
<dd>
Any character that is not whitespace and is not part of a token or
comment is illegal.

<P>
<dt> LENGTH LIMITS
<dd>
You may not assume any limits on the lengths of identifiers, string literals,
integer literals, comments, etc.
</dl>

<a name="scannerActions">
<h2>What the Scanner Should Do</h2>
</a>

The main job of the scanner is to identify and return the next token.
The value to be returned includes:
<UL>
  <LI> The token "name" (e.g., <tt>INTLITERAL</tt>).
       Token names are defined in the file
       <A HREF="../PROG2/sym.java"><tt>sym.java</tt></a>.
  <LI> The line number in the input file on which the token starts.
  <LI><name ="charcount">
       The number of the character on that line at which the token starts.
  <LI> For identifiers, integer literals, double literals,
       and string literals: the actual
       value (a <tt>String</tt>, an <tt>int</tt>, a <tt>double</tt>,
       or a <tt>String</tt>, respectively).
       For a string literal, the value should include the double quotes
       that surround the string,
       as well as any backslashes used inside the string as part of an
       "escaped" character.
</UL>

<P>
Your scanner will return this information by creating a new <tt>Symbol</tt>
object in the action associated with each regular expression that defines
a token (the <tt>Symbol</tt> type is defined in <tt>java_cup.runtime</tt>;
you don't need to look at that definition).
A <tt>Symbol</tt> includes a field
of type <tt>int</tt> for the token name, and a field of type
<tt>Object</tt> (named <tt>value</tt>), which will be used for the line
and character numbers and for the token value (for identifiers and
literals).
See <A HREF="../PROG2/Little.jlex"><tt>Little.jlex</tt></a>
for examples of how to call the <tt>Symbol</tt> constructor.
See <A HREF="../PROG2/P2.java"><tt>P2.java</tt></a> for code that accesses
the fields of a <tt>Symbol</tt>.
<P>
In your compiler, the <tt>value</tt> field of a <tt>Symbol</tt> will actually
be of type <tt>TokenVal</tt>;
that type is defined in
<A HREF="../PROG2/Little.jlex"><tt>Little.jlex</tt></a>.
Every <tt>TokenVal</tt> includes a <tt>linenum</tt> field, and a
<tt>charnum</tt> field (line and character numbers start counting from 1,
not 0).
Subtypes of <tt>TokenVal</tt> with more fields will be used for
the values associated with identifier, integer literal, and string literal
tokens.
These subtypes, <tt>IntLitTokenVal</tt>, <tt>DblLitTokenVal</tt>,
<tt>IdLitTokenVal</tt>,  and <tt>StrLitTokenVal</tt> are also defined in
<A HREF="../PROG2/Little.jlex"><tt>Little.jlex</tt></a>.

<P>
Line counting is done by the scanner generated by
JLex (the variable <tt>yyline</tt> holds the current line number, counting
from 0), but you will have to include
code to keep track of the current character number on that line.
The code
in <A HREF="../PROG2/Little.jlex"><tt>Little.jlex</tt></a>
does this for the patterns that it defines, and you should be able to
figure out how to do the same thing for the new patterns that you add.

<p>
The JLex scanner also provides a method <tt>yytext</tt> that returns
the actual text that matches a regular expression.
You will find it useful to use this method in the actions you write
in your JLex specification.

<a name="ex">
<p>
Note that, for the integer literal token, you will need to convert
a <tt>String</tt> (the value scanned) to an <tt>int</tt> (the
value to be returned).
You should use code like the following:
<pre>
  double d = (new Double(yytext())).doubleValue(); // convert String to double
  // INSERT CODE HERE TO CHECK FOR BAD VALUE -- SEE ERRORS AND WARNINGS BELOW
  int k =  (new Integer(yytext())).intValue();    // convert to int
</pre>

<a name="errors">
<h2>Errors and Warnings</h2>
</a>

The scanner should handle the following errors as indicated:
<dl>
<dt> <em>Illegal characters</em>.
<dd> Issue the error message:
     <tt>ignoring illegal character: ch</tt> (where <tt>ch</tt> is the
     illegal character) and ignore the character.
<dt> <em>Unterminated string literals</em>
<dd> A string literal is considered to be unterminated if there is a
     newline or end-of-file before the closing quote.
     Issue the error message: <tt>ignoring unterminated string literal</tt>
     and ignore the unterminated string literal (start looking for the
     next token after the newline).
<dt> <em>Bad string literals</em>
<dd> A string literal is "bad" if it includes a bad "escaped" character;
     i.e., a backslash followed by something other than an <tt>n</tt>, a
     <tt>t</tt>, a single quote, a double quote, or another backslash.
     Issue the error message:
     <tt>ignoring string literal with bad escaped character</tt>
     and ignore the string literal (start looking for the
     next token after the closing quote).
     If the string literal has a bad escaped character <em>and</em> is
     unterminated, issue the error message
     <tt>ignoring unterminated string literal with bad escaped character</tt>,
     and ignore the bad string literal (start looking for the next token
     after the newline).
     Note that a string literal that has a newline immediately after a
     backslash should be treated as having a bad escaped character and
     being unterminated.  For example, given:
     <br><ul><tt>
     "very bad string \
     <br>abc
     </tt></ul>
     the scanner should report an unterminated string literal with a bad
     escaped character on line 1, and an identifier on line 2.
<dt> <em>Unterminated comments</em>
<dd> A file has an unterminated comment if it has the two-character
     sequence "/*" with no matching "*/" (i.e., the file ends before 
     a "*/" is seen).
     Issue the error message: <tt>unterminated comment</tt>
<dt> <em>Bad integer literals</em> (integer literals larger than
     <tt>Integer.MAX_VALUE</tt>).
<dd> Issue the warning message:
     <tt>integer literal too large; using max value</tt>
     and return <tt>Integer.MAX_VALUE</tt> as the value for that token.
</dl>
For unterminated comments, unterminated string literals, bad string
literals, and bad integer literals, the line and column numbers used
in the error message should correspond to the position of
the <em>first</em> character in the comment/string-literal/integer-literal.
<P>
Note that there is no <tt>eof</tt> pattern in JLex.
To recognize an unterminated comment you should simply write a JLex
pattern that matches the start of a comment ("/*"), followed by
anything other than the end of the comment ("*/").
Since the scanner always finds the <em>longest</em> prefix of the input that
matches a pattern, that pattern will only match an unterminated comment.
You will need a similar pattern for an unterminated string literal
where end-of-file occurs before a newline or a closing quote.
<P>
Use the <tt>fatal</tt> and <tt>warn</tt> methods of the <tt>Errors</tt> class
to print error and warning messages.
Be sure to use <em>exactly</em> the wording given above for each message
so that the output of your scanner will match the output that we expect
when we test your code.

<a name="main">
<h2>The Main Program</h2>
</a>

In addition to specifying a scanner, you should extend the main
program in <A HREF="../PROG2/P2.java"><tt>P2.java</tt></a>.
The program opens a file called <tt>inTokens</tt> for reading;
then the program loops, calling the scanner's <tt>next_token</tt> method
until the special end-of-file token is returned.
For each token, it writes the corresponding lexeme to a file called
<tt>inTokens.out</tt>.
You can use <tt>diff</tt> to compare the input and output files
(<tt>diff inTokens inTokens.out</tt>).
If they differ, you've found an error in the scanner.
Note that you will need to write the <tt>inTokens</tt> file.
<P>
You will probably want to change <tt>P2.java</tt> to read multiple
input files so that you can test other features of the scanner.
You will need to create a new scanner each time, and you will need to set
<tt>CharNum.num</tt> back to one each time (to get correct character numbers
for the first line of input).
Note that the input files do <em>not</em> have to be legal <code>Little</code>
or C programs,
just sequences of characters that correspond to <tt>Little</tt> tokens.
Running <tt>P2</tt> should exercise all
of the code in your scanner, including the code that reports errors.
<b>Don't forget to include code that tests whether the correct
character number is returned for every token!</b>
<P>
To test that your scanner correctly handles an unterminated string literal
with end-of-file before the closing quote, 
you may use the file
<A HREF="../PROG2/eof">~cs536-1/public/html/PROG2/eof</A>.
On a Linux machine, you can tell that there is no final newline by
typing: <tt>cat eof</tt>
You should see your command-line prompt at the <em>end</em> of the
last line of the output instead of at the beginning of the following
line.

<a name="findErrors">
<h2>Finding Errors in a Scanner</h2>
<P>
So that you can run your test code before completing your own scanner,
all of the <tt>.class</tt> files needed for a scanner are available to
you in <tt>~cs536-1/public/html/PROG2/CLASS-FILES</tt>.
This scanner has six errors.
You should use your test code to find those errors, and create a file
named <tt>Errors.txt</tt> that contains six lines, one for each of the
errors.
For example, if you discover that the scanner returns the wrong token
when the input contains a left parenthesis, one line of <tt>Errors.txt</tt>
would contain a left parenthesis.
Hand in your <tt>Errors.txt</tt> file on Thursday, Feb 23 along with your
<tt>P2.java</tt> and its input file(s).
If your <tt>P2.java</tt> reads from my <tt>eof</tt> file, hand
that in, too.

<a name="pairs">
<h2>Working in Pairs</h2>
</a>
<P>
Graduate and special students must work alone on this assignment.
Undergraduates may work alone or in pairs.
<P>
If you plan to work with a partner, you must let us know (via email)
<em><b>no later than February 16</b></em>.
<P>
If you want to work with a partner but don't have one,
let us know and we will find you one.
<P>
If you are working with a partner and you
decide to split up, you <em><b>must</b></em> tell me that via e-mail 
so that we can arrange how to divide up any code that has already
been written.
<P>
Below is some advice on how to work in pairs.
<P>
This assignment involves two main tasks:
<OL>
  <LI> Writing the scanner specification (<tt>Little.jlex</tt>).
  <LI> Writing the main program (<tt>P2.java</tt>) to test your scanner.
</OL>
An excellent way to work together is to do <i>pair programming</i>:
Meet frequently and work closely together on all three tasks.
Sit down together in front of a computer.
Take turns "driving" (controlling the keyboard and mouse)
and "verifying" (watching what the driver does and spotting mistakes).
Work together on all aspects of the project: design, coding, debugging,
and testing.
Often the main advantage of having a partner is not having somebody to
write half the code, but having somebody to bounce ideas off of and
to help spot your mistakes.
<P>
If you decide to divide up the work, you are <b>strongly</b> encouraged
to work together on task (1) since both partners are responsible for
learning how to use JLex.
You should also work together on testing;
in particular, you should each test the other's work.
<P>
Here is one reasonable way to divide up the project:
<UL>
  <LI> Divide up the tokens into two parts, one part for each person.
  <LI> Each person extends their own copy of <tt>Little.jlex</tt>
       by adding rules for their half of the tokens, and extends
       their own copy of the main program to handle those same tokens.
  <LI> Decide together how your <tt>P2.java</tt> should work, and write
       that code.
  <LI> Write test input files for your own tokens, and for the other
       person's tokens, too.
  <LI> After each person makes sure that their scanner and main program
       work on their own tokens, combine the two (it should be pretty easy
       to cut and paste one person's JLex rules into the other person's
       <tt>Little.jlex</tt>).
  <LI> Talk about what needs to be tested, and decide together what your
       final test input files should include.
  <LI> Do <em>not</em> try to implement all of your half of the tokens
       at once.  Instead, implement just a few to start with to make
       sure that you both know what you're doing, and that you're able
       to combine your work easily.
</UL>
The most challenging JLex rules are for comments and for the
<tt>STRINGLITERAL</tt> token (for which you will need several rules: for a
correct string literal, for an unterminated string literal, for
a string literal that contains a bad escaped character, and for a
string literal that contains a bad escaped character <em>and</em>
is unterminated).
Be sure to divide these up so that each person gets to work on some of them.
<P>
It is <b>very</b> important to set deadlines and to stick to them.
I suggest that you choose one person to be the "project leader" (plan
to switch off on future assignments).
The project leader should propose a division of tokens, as well as deadlines
for completing phases of the program, and should be responsible for
keeping the most recent version of the combined code (be sure to keep
back-up versions, too, perhaps in another directory or using a version-control
system like RCS or SVN).
<P>
To share your code, you can either use e-mail, or the project leader
can create a directory for the combined code (<em>not</em> the directory
in which that person develops the code).
I suggest that you create a new top-level directory (i.e., at the same
level as your <tt>public</tt> and <tt>private</tt> directories), named
something like <tt>cs536-P2</tt>.
To set the permissions of the directory for the combined code to allow your
partner to write into it, change to that directory and type:
<UL>
<pre>
fs setacl . &lt;login&gt; write
</pre>
</UL>
using your partner's CS login in place of <tt>&lt;login&gt;</tt>.
You should also prevent any other access by typing:
<UL>
<pre>
fs setacl . system:anyuser none
</pre>
</UL>
in the new directory that you create (<em>not</em> in your top-level
directory).
To see what the permissions are in your current directory, type:
<UL>
<pre>
fs listacl
</pre>
</UL>
<P>
Do <em>not</em> try to share by letting your partner log in to your account.
Departmental and University policy prohibits your revealing your password
to anybody else, including your partner.

<P>
<a name="turningIn">
<h2>What to Turn In</h2>
</a>

By midnight on February 23, copy your <code>P2.java</code>, the files
that it reads, and your <tt>Errors.txt</tt> file to your handin directory.

To hand in the rest of your code, copy all of the files that are
needed to create your scanner, as well as your <tt>Makefile</tt> to
your handin directory.
Please do <em>not</em> create any subdirectories in your handin directory,
and do <em>not</em> copy any <tt>.class</tt> files.
<P>
If you are working with a partner <b>only one</b> of you should hand in files.
Include a comment at the top of <tt>P2.java</tt> with the names of both
partners.
	
</body>
</html>
